{"ast":null,"code":"import _classCallCheck from \"E:/angular-website-example/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/angular-website-example/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { EventEmitter, Directive, ElementRef, NgZone, Input, Output, NgModule } from '@angular/core';\nimport { init } from 'echarts';\nimport { of, EMPTY, fromEvent, Observable } from 'rxjs';\nimport { debounceTime, switchMap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar ChangeFilter = /*#__PURE__*/function () {\n  /**\n   * @param {?} _changes\n   */\n  function ChangeFilter(_changes) {\n    _classCallCheck(this, ChangeFilter);\n\n    this._changes = _changes;\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  _createClass(ChangeFilter, [{\n    key: \"notEmpty\",\n\n    /**\n     * @template T\n     * @param {?} key\n     * @return {?}\n     */\n    value: function notEmpty(key) {\n      if (this._changes[key]) {\n        /** @type {?} */\n        var value = this._changes[key].currentValue;\n\n        if (value !== undefined && value !== null) {\n          return of(value);\n        }\n      }\n\n      return EMPTY;\n    }\n    /**\n     * @template T\n     * @param {?} key\n     * @return {?}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      if (this._changes[key]) {\n        /** @type {?} */\n        var value = this._changes[key].currentValue;\n        return of(value);\n      }\n\n      return EMPTY;\n    }\n    /**\n     * @template T\n     * @param {?} key\n     * @return {?}\n     */\n\n  }, {\n    key: \"notFirst\",\n    value: function notFirst(key) {\n      if (this._changes[key] && !this._changes[key].isFirstChange()) {\n        /** @type {?} */\n        var value = this._changes[key].currentValue;\n        return of(value);\n      }\n\n      return EMPTY;\n    }\n    /**\n     * @template T\n     * @param {?} key\n     * @return {?}\n     */\n\n  }, {\n    key: \"notFirstAndEmpty\",\n    value: function notFirstAndEmpty(key) {\n      if (this._changes[key] && !this._changes[key].isFirstChange()) {\n        /** @type {?} */\n        var value = this._changes[key].currentValue;\n\n        if (value !== undefined && value !== null) {\n          return of(value);\n        }\n      }\n\n      return EMPTY;\n    }\n  }], [{\n    key: \"of\",\n    value: function of(changes) {\n      return new ChangeFilter(changes);\n    }\n  }]);\n\n  return ChangeFilter;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ChangeFilter.prototype._changes;\n}\n\nvar NgxEchartsDirective = /*@__PURE__*/function () {\n  var NgxEchartsDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} el\n     * @param {?} ngZone\n     */\n    function NgxEchartsDirective(el, ngZone) {\n      _classCallCheck(this, NgxEchartsDirective);\n\n      this.el = el;\n      this.ngZone = ngZone;\n      this.autoResize = true;\n      this.loadingType = 'default';\n      this.detectEventChanges = true; // deprecated, left for compatibility reasons to avoid triggering major version\n      // deprecated, left for compatibility reasons to avoid triggering major version\n      // ngx-echarts events\n\n      this.chartInit = new EventEmitter(); // echarts mouse events\n\n      this.chartClick = this.createLazyEvent('click');\n      this.chartDblClick = this.createLazyEvent('dblclick');\n      this.chartMouseDown = this.createLazyEvent('mousedown');\n      this.chartMouseMove = this.createLazyEvent('mousemove');\n      this.chartMouseUp = this.createLazyEvent('mouseup');\n      this.chartMouseOver = this.createLazyEvent('mouseover');\n      this.chartMouseOut = this.createLazyEvent('mouseout');\n      this.chartGlobalOut = this.createLazyEvent('globalout');\n      this.chartContextMenu = this.createLazyEvent('contextmenu'); // echarts mouse events\n\n      this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');\n      this.chartLegendSelected = this.createLazyEvent('legendselected');\n      this.chartLegendUnselected = this.createLazyEvent('legendunselected');\n      this.chartLegendScroll = this.createLazyEvent('legendscroll');\n      this.chartDataZoom = this.createLazyEvent('datazoom');\n      this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');\n      this.chartTimelineChanged = this.createLazyEvent('timelinechanged');\n      this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');\n      this.chartRestore = this.createLazyEvent('restore');\n      this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');\n      this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');\n      this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');\n      this.chartPieSelected = this.createLazyEvent('pieselected');\n      this.chartPieUnselected = this.createLazyEvent('pieunselected');\n      this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');\n      this.chartMapSelected = this.createLazyEvent('mapselected');\n      this.chartMapUnselected = this.createLazyEvent('mapunselected');\n      this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');\n      this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');\n      this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');\n      this.chartBrush = this.createLazyEvent('brush');\n      this.chartBrushSelected = this.createLazyEvent('brushselected');\n      this.chartRendered = this.createLazyEvent('rendered');\n      this.chartFinished = this.createLazyEvent('finished');\n      this.currentOffsetWidth = 0;\n      this.currentOffsetHeight = 0;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    _createClass(NgxEchartsDirective, [{\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var _this = this;\n\n        /** @type {?} */\n        var filter = ChangeFilter.of(changes);\n        filter.notFirstAndEmpty('options').subscribe(\n        /**\n        * @param {?} opt\n        * @return {?}\n        */\n\n        /**\n        * @param {?} opt\n        * @return {?}\n        */\n        function (opt) {\n          return _this.onOptionsChange(opt);\n        });\n        filter.notFirstAndEmpty('merge').subscribe(\n        /**\n        * @param {?} opt\n        * @return {?}\n        */\n\n        /**\n        * @param {?} opt\n        * @return {?}\n        */\n        function (opt) {\n          return _this.setOption(opt);\n        });\n        filter.has('loading').subscribe(\n        /**\n        * @param {?} v\n        * @return {?}\n        */\n\n        /**\n        * @param {?} v\n        * @return {?}\n        */\n        function (v) {\n          return _this.toggleLoading(!!v);\n        });\n        filter.notFirst('theme').subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.refreshChart();\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this2 = this;\n\n        this.resizeSub = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          if (_this2.autoResize && window.innerWidth !== _this2.currentWindowWidth) {\n            _this2.currentWindowWidth = window.innerWidth;\n            _this2.currentOffsetWidth = _this2.el.nativeElement.offsetWidth;\n            _this2.currentOffsetHeight = _this2.el.nativeElement.offsetHeight;\n\n            _this2.resize();\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.resizeSub) {\n          this.resizeSub.unsubscribe();\n        }\n\n        this.dispose();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        // No heavy work in DoCheck!\n        if (this.chart && this.autoResize) {\n          /** @type {?} */\n          var offsetWidth = this.el.nativeElement.offsetWidth;\n          /** @type {?} */\n\n          var offsetHeight = this.el.nativeElement.offsetHeight;\n\n          if (this.currentOffsetWidth !== offsetWidth || this.currentOffsetHeight !== offsetHeight) {\n            this.currentOffsetWidth = offsetWidth;\n            this.currentOffsetHeight = offsetHeight;\n            this.resize();\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this3 = this;\n\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this3.initChart();\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this.chart) {\n          this.chart.dispose();\n          this.chart = null;\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"resize\",\n      value: function resize() {\n        if (this.chart) {\n          this.chart.resize();\n        }\n      }\n      /**\n       * @private\n       * @param {?} loading\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggleLoading\",\n      value: function toggleLoading(loading) {\n        if (this.chart) {\n          loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();\n        }\n      }\n      /**\n       * @private\n       * @param {?} option\n       * @param {?=} opts\n       * @return {?}\n       */\n\n    }, {\n      key: \"setOption\",\n      value: function setOption(option, opts) {\n        if (this.chart) {\n          this.chart.setOption(option, opts);\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"refreshChart\",\n      value: function refreshChart() {\n        this.dispose();\n        this.initChart();\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"createChart\",\n      value: function createChart() {\n        var _this4 = this;\n\n        this.currentWindowWidth = window.innerWidth;\n        this.currentOffsetWidth = this.el.nativeElement.offsetWidth;\n        this.currentOffsetHeight = this.el.nativeElement.offsetHeight;\n        /** @type {?} */\n\n        var dom = this.el.nativeElement;\n\n        if (window && window.getComputedStyle) {\n          /** @type {?} */\n          var prop = window.getComputedStyle(dom, null).getPropertyValue('height');\n\n          if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {\n            dom.style.height = '400px';\n          }\n        }\n\n        return this.ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          return init(dom, _this4.theme, _this4.initOpts);\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"initChart\",\n      value: function initChart() {\n        this.onOptionsChange(this.options);\n\n        if (this.merge && this.chart) {\n          this.setOption(this.merge);\n        }\n      }\n      /**\n       * @private\n       * @param {?} opt\n       * @return {?}\n       */\n\n    }, {\n      key: \"onOptionsChange\",\n      value: function onOptionsChange(opt) {\n        if (opt) {\n          if (!this.chart) {\n            this.chart = this.createChart();\n            this.chartInit.emit(this.chart);\n          }\n\n          this.chart.setOption(this.options, true);\n        }\n      } // allows to lazily bind to only those events that are requested through the `@Output` by parent components\n      // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info\n\n      /**\n       * @private\n       * @template T\n       * @param {?} eventName\n       * @return {?}\n       */\n\n    }, {\n      key: \"createLazyEvent\",\n      value: function createLazyEvent(eventName) {\n        var _this5 = this;\n\n        return (\n          /** @type {?} */\n          this.chartInit.pipe(switchMap(\n          /**\n          * @param {?} chart\n          * @return {?}\n          */\n          function (chart) {\n            return new Observable(\n            /**\n            * @param {?} observer\n            * @return {?}\n            */\n\n            /**\n            * @param {?} observer\n            * @return {?}\n            */\n            function (observer) {\n              chart.on(eventName,\n              /**\n              * @param {?} data\n              * @return {?}\n              */\n              function (data) {\n                return _this5.ngZone.run(\n                /**\n                * @return {?}\n                */\n                function () {\n                  return observer.next(data);\n                });\n              });\n              return (\n                /**\n                * @return {?}\n                */\n                function () {\n                  return chart.off(eventName);\n                }\n              );\n            });\n          }))\n        );\n      }\n    }]);\n\n    return NgxEchartsDirective;\n  }();\n\n  NgxEchartsDirective.ɵfac = function NgxEchartsDirective_Factory(t) {\n    return new (t || NgxEchartsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  NgxEchartsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: NgxEchartsDirective,\n    selectors: [[\"echarts\"], [\"\", \"echarts\", \"\"]],\n    inputs: {\n      autoResize: \"autoResize\",\n      loadingType: \"loadingType\",\n      detectEventChanges: \"detectEventChanges\",\n      options: \"options\",\n      theme: \"theme\",\n      loading: \"loading\",\n      initOpts: \"initOpts\",\n      merge: \"merge\",\n      loadingOpts: \"loadingOpts\"\n    },\n    outputs: {\n      chartInit: \"chartInit\",\n      chartClick: \"chartClick\",\n      chartDblClick: \"chartDblClick\",\n      chartMouseDown: \"chartMouseDown\",\n      chartMouseMove: \"chartMouseMove\",\n      chartMouseUp: \"chartMouseUp\",\n      chartMouseOver: \"chartMouseOver\",\n      chartMouseOut: \"chartMouseOut\",\n      chartGlobalOut: \"chartGlobalOut\",\n      chartContextMenu: \"chartContextMenu\",\n      chartLegendSelectChanged: \"chartLegendSelectChanged\",\n      chartLegendSelected: \"chartLegendSelected\",\n      chartLegendUnselected: \"chartLegendUnselected\",\n      chartLegendScroll: \"chartLegendScroll\",\n      chartDataZoom: \"chartDataZoom\",\n      chartDataRangeSelected: \"chartDataRangeSelected\",\n      chartTimelineChanged: \"chartTimelineChanged\",\n      chartTimelinePlayChanged: \"chartTimelinePlayChanged\",\n      chartRestore: \"chartRestore\",\n      chartDataViewChanged: \"chartDataViewChanged\",\n      chartMagicTypeChanged: \"chartMagicTypeChanged\",\n      chartPieSelectChanged: \"chartPieSelectChanged\",\n      chartPieSelected: \"chartPieSelected\",\n      chartPieUnselected: \"chartPieUnselected\",\n      chartMapSelectChanged: \"chartMapSelectChanged\",\n      chartMapSelected: \"chartMapSelected\",\n      chartMapUnselected: \"chartMapUnselected\",\n      chartAxisAreaSelected: \"chartAxisAreaSelected\",\n      chartFocusNodeAdjacency: \"chartFocusNodeAdjacency\",\n      chartUnfocusNodeAdjacency: \"chartUnfocusNodeAdjacency\",\n      chartBrush: \"chartBrush\",\n      chartBrushSelected: \"chartBrushSelected\",\n      chartRendered: \"chartRendered\",\n      chartFinished: \"chartFinished\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return NgxEchartsDirective;\n}();\n\nif (false) {\n  /** @type {?} */\n  NgxEchartsDirective.prototype.options;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.theme;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.loading;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.initOpts;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.merge;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.autoResize;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.loadingType;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.loadingOpts;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.detectEventChanges;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartInit;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartClick;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartDblClick;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMouseDown;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMouseMove;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMouseUp;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMouseOver;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMouseOut;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartGlobalOut;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartContextMenu;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartLegendSelectChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartLegendSelected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartLegendUnselected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartLegendScroll;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartDataZoom;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartDataRangeSelected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartTimelineChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartTimelinePlayChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartRestore;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartDataViewChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMagicTypeChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartPieSelectChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartPieSelected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartPieUnselected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMapSelectChanged;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMapSelected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartMapUnselected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartAxisAreaSelected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartFocusNodeAdjacency;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartUnfocusNodeAdjacency;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartBrush;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartBrushSelected;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartRendered;\n  /** @type {?} */\n\n  NgxEchartsDirective.prototype.chartFinished;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.chart;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.currentOffsetWidth;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.currentOffsetHeight;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.currentWindowWidth;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.resizeSub;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.el;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgxEchartsDirective.prototype.ngZone;\n}\n\nvar NgxEchartsModule = /*@__PURE__*/function () {\n  var NgxEchartsModule = function NgxEchartsModule() {\n    _classCallCheck(this, NgxEchartsModule);\n  };\n\n  NgxEchartsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: NgxEchartsModule\n  });\n  NgxEchartsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function NgxEchartsModule_Factory(t) {\n      return new (t || NgxEchartsModule)();\n    },\n    imports: [[]]\n  });\n  return NgxEchartsModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxEchartsModule, {\n    declarations: [NgxEchartsDirective],\n    exports: [NgxEchartsDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { NgxEchartsModule, NgxEchartsDirective as ɵa };","map":null,"metadata":{},"sourceType":"module"}